# sharedpacker

A cli tool that searches for shared library dependencies of an executable, collects a dependency tree, and copies the executable, and all of its dependencies to a new folder. This new folder now contains every single library that the executable depends on, and can be copied to any linux-like OS.

`sharedpacker` also changes the binaries it outputs to use the specific linker that it copied in order to make sure that they use exactly the same linker when run on a different machine.

**`sharedpacker` uses `ldd` and `patchelf` so you must have those installed to use this properly.**

# What `sharedpacker` does can be summarized by

- parse `ldd <some-executable>` to get a map of lib names to lib paths
- recursively iterate over every required lib name in `patchelf --print-needed <some-executable>` and repeat the previous step until we have a full dependency tree
- flatten the dependency tree and remove duplicates, and then for every unique file, copy to a new archive
- for every file that is copied, do: `patchelf --set-interpreter ./<linkername> --set-rpath . <libname>` to use the exact linker
- (optionally) create a wrapper script that invokes your program with the exact linker used and with the correct library path. otherwise, without the wrapper script you can do: `LD_LIBRARY_PATH=. ./my-program`

# Install

I have provided a release of `sharedpacker` built for `x86-64-unknown-linux-musl` which should run on any linux machine, but otherwise you can compile it yourself with:

```sh
git clone https://github.com/nikita-skobov/sharedpacker
cd sharedpacker/sharedpacker/
cargo build --release
# optionally install it:
cp target/release/sharedpacker /usr/local/bin/
```

# Examples


```sh
sharedpacker /usr/bin/ls
# creates the default archive: ./sharedpacker_out/
# which will contain:
#
# ld-linux-x86-64.so.2
# libcap.so.2
# libc.so.6
# ls
```

If you run it again youd get an error because `./sharedpacker_out` already exists. use `--force` to override it:

```sh
sharedpacker /usr/bin/ls --force
```

Or otherwise specify a different output folder name:

```sh
sharedpacker /usr/bin/ls --output otherfolder
# puts the output archive in ./otherfolder/
```

Optionally create a wrapper script

```sh
sharedpacker /usr/bin/ls --make-wrapper

# ld-linux-x86-64.so.2
# libcap.so.2
# libc.so.6
# ls
# .ls-original
```

where `ls` is now a shell script, and `.ls-original` is the original executable.

The contents of the `ls` script look like:

```sh
#!/usr/bin/env bash

SCRIPTPATH="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )"
"$SCRIPTPATH/ld-linux-x86-64.so.2" --library-path "$SCRIPTPATH" "$SCRIPTPATH/.ls-original" "$@"
```

Note that the `ld-linux-x86-64.so.2` and `.ls-original` are generated by the sharedpacker tool. those values will be different depending on what executable is used.


# Why written in rust?

This can of course be a somewhat trivial shell script, but i decided to write it in rust because i wanted a convenient way to handle dependency tree, and mapping lib names to files. hashmaps are not convenient in bash.

# LICENSE

AGPL3
